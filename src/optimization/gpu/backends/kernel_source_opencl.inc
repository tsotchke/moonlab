/**
 * @file kernel_source_opencl.inc
 * @brief Embedded OpenCL kernel source as C string literal
 *
 * This file is auto-generated or manually maintained.
 * Include in gpu_opencl.c to embed kernel source.
 */

"// Complex number arithmetic\n"
"typedef float2 complex_t;\n"
"\n"
"inline complex_t cmul(complex_t a, complex_t b) {\n"
"    return (complex_t)(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n"
"}\n"
"\n"
"inline complex_t cadd(complex_t a, complex_t b) { return a + b; }\n"
"inline complex_t csub(complex_t a, complex_t b) { return a - b; }\n"
"inline float cabs2(complex_t z) { return z.x * z.x + z.y * z.y; }\n"
"inline complex_t cscale(complex_t z, float s) { return z * s; }\n"
"inline complex_t cneg(complex_t z) { return -z; }\n"
"inline complex_t cpolar(float r, float theta) {\n"
"    return (complex_t)(r * cos(theta), r * sin(theta));\n"
"}\n"
"\n"
"// Hadamard transform - single qubit\n"
"__kernel void hadamard_transform(\n"
"    __global complex_t* amplitudes,\n"
"    const uint qubit_index,\n"
"    const uint state_dim\n"
") {\n"
"    uint tid = get_global_id(0);\n"
"    uint stride = 1u << qubit_index;\n"
"    uint num_pairs = state_dim / 2;\n"
"    if (tid >= num_pairs) return;\n"
"    uint mask = stride - 1;\n"
"    uint base = (tid >> qubit_index) << (qubit_index + 1);\n"
"    uint offset = tid & mask;\n"
"    uint idx0 = base + offset;\n"
"    uint idx1 = idx0 + stride;\n"
"    complex_t amp0 = amplitudes[idx0];\n"
"    complex_t amp1 = amplitudes[idx1];\n"
"    const float inv_sqrt2 = 0.70710678118f;\n"
"    complex_t new_amp0 = cscale(cadd(amp0, amp1), inv_sqrt2);\n"
"    complex_t new_amp1 = cscale(csub(amp0, amp1), inv_sqrt2);\n"
"    amplitudes[idx0] = new_amp0;\n"
"    amplitudes[idx1] = new_amp1;\n"
"}\n"
"\n"
"// Hadamard all qubits\n"
"__kernel void hadamard_all_qubits(\n"
"    __global complex_t* amplitudes,\n"
"    const uint num_qubits,\n"
"    const uint state_dim\n"
") {\n"
"    uint tid = get_global_id(0);\n"
"    if (tid >= state_dim) return;\n"
"    complex_t amp = amplitudes[tid];\n"
"    uint hamming = popcount(tid);\n"
"    float sign = (hamming & 1) ? -1.0f : 1.0f;\n"
"    float scale = 1.0f / sqrt((float)(1u << num_qubits));\n"
"    amplitudes[tid] = cscale(amp, sign * scale);\n"
"}\n"
"\n"
"// Oracle - single target\n"
"__kernel void oracle_single_target(\n"
"    __global complex_t* amplitudes,\n"
"    const uint target\n"
") {\n"
"    uint tid = get_global_id(0);\n"
"    if (tid == target) {\n"
"        amplitudes[tid] = cneg(amplitudes[tid]);\n"
"    }\n"
"}\n"
"\n"
"// Oracle - multiple targets\n"
"__kernel void sparse_oracle(\n"
"    __global complex_t* amplitudes,\n"
"    __global const uint* marked_states,\n"
"    const uint num_marked,\n"
"    const uint state_dim\n"
") {\n"
"    uint tid = get_global_id(0);\n"
"    if (tid >= state_dim) return;\n"
"    for (uint i = 0; i < num_marked; i++) {\n"
"        if (tid == marked_states[i]) {\n"
"            amplitudes[tid] = cneg(amplitudes[tid]);\n"
"            break;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Diffusion sum phase\n"
"__kernel void diffusion_sum(\n"
"    __global const complex_t* amplitudes,\n"
"    __global complex_t* partial_sums,\n"
"    __local complex_t* local_sums,\n"
"    const uint state_dim\n"
") {\n"
"    uint tid = get_global_id(0);\n"
"    uint lid = get_local_id(0);\n"
"    uint group_id = get_group_id(0);\n"
"    uint local_size = get_local_size(0);\n"
"    complex_t sum = (complex_t)(0.0f, 0.0f);\n"
"    uint grid_size = get_global_size(0);\n"
"    for (uint i = tid; i < state_dim; i += grid_size) {\n"
"        sum = cadd(sum, amplitudes[i]);\n"
"    }\n"
"    local_sums[lid] = sum;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    for (uint s = local_size / 2; s > 0; s >>= 1) {\n"
"        if (lid < s) {\n"
"            local_sums[lid] = cadd(local_sums[lid], local_sums[lid + s]);\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"    if (lid == 0) {\n"
"        partial_sums[group_id] = local_sums[0];\n"
"    }\n"
"}\n"
"\n"
"// Diffusion apply phase\n"
"__kernel void diffusion_apply(\n"
"    __global complex_t* amplitudes,\n"
"    __global const complex_t* avg_buffer,\n"
"    const uint state_dim\n"
") {\n"
"    uint tid = get_global_id(0);\n"
"    if (tid >= state_dim) return;\n"
"    complex_t avg = avg_buffer[0];\n"
"    complex_t two_avg = cscale(avg, 2.0f);\n"
"    amplitudes[tid] = csub(two_avg, amplitudes[tid]);\n"
"}\n"
"\n"
"// Fused diffusion for small states\n"
"__kernel void grover_diffusion_fused(\n"
"    __global complex_t* amplitudes,\n"
"    __local complex_t* local_amps,\n"
"    const uint num_qubits,\n"
"    const uint state_dim\n"
") {\n"
"    uint tid = get_global_id(0);\n"
"    uint lid = get_local_id(0);\n"
"    uint local_size = get_local_size(0);\n"
"    if (tid < state_dim) {\n"
"        local_amps[lid] = amplitudes[tid];\n"
"    } else {\n"
"        local_amps[lid] = (complex_t)(0.0f, 0.0f);\n"
"    }\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    __local complex_t shared_sum[256];\n"
"    complex_t local_sum = (complex_t)(0.0f, 0.0f);\n"
"    for (uint i = lid; i < state_dim; i += local_size) {\n"
"        local_sum = cadd(local_sum, local_amps[i]);\n"
"    }\n"
"    shared_sum[lid] = local_sum;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    for (uint s = local_size / 2; s > 0; s >>= 1) {\n"
"        if (lid < s && lid + s < local_size) {\n"
"            shared_sum[lid] = cadd(shared_sum[lid], shared_sum[lid + s]);\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"    complex_t avg = cscale(shared_sum[0], 1.0f / (float)state_dim);\n"
"    complex_t two_avg = cscale(avg, 2.0f);\n"
"    if (tid < state_dim) {\n"
"        amplitudes[tid] = csub(two_avg, local_amps[lid]);\n"
"    }\n"
"}\n"
"\n"
"// Compute probabilities\n"
"__kernel void compute_probabilities(\n"
"    __global const complex_t* amplitudes,\n"
"    __global float* probabilities,\n"
"    const uint state_dim\n"
") {\n"
"    uint tid = get_global_id(0);\n"
"    if (tid >= state_dim) return;\n"
"    complex_t amp = amplitudes[tid];\n"
"    probabilities[tid] = cabs2(amp);\n"
"}\n"
"\n"
"// Normalize state\n"
"__kernel void normalize_state(\n"
"    __global complex_t* amplitudes,\n"
"    const float norm,\n"
"    const uint state_dim\n"
") {\n"
"    uint tid = get_global_id(0);\n"
"    if (tid >= state_dim) return;\n"
"    float inv_norm = 1.0f / norm;\n"
"    amplitudes[tid] = cscale(amplitudes[tid], inv_norm);\n"
"}\n"
"\n"
"// Pauli X gate\n"
"__kernel void pauli_x(\n"
"    __global complex_t* amplitudes,\n"
"    const uint qubit_index,\n"
"    const uint state_dim\n"
") {\n"
"    uint tid = get_global_id(0);\n"
"    uint stride = 1u << qubit_index;\n"
"    uint num_pairs = state_dim / 2;\n"
"    if (tid >= num_pairs) return;\n"
"    uint mask = stride - 1;\n"
"    uint base = (tid >> qubit_index) << (qubit_index + 1);\n"
"    uint offset = tid & mask;\n"
"    uint idx0 = base + offset;\n"
"    uint idx1 = idx0 + stride;\n"
"    complex_t temp = amplitudes[idx0];\n"
"    amplitudes[idx0] = amplitudes[idx1];\n"
"    amplitudes[idx1] = temp;\n"
"}\n"
"\n"
"// Pauli Y gate\n"
"__kernel void pauli_y(\n"
"    __global complex_t* amplitudes,\n"
"    const uint qubit_index,\n"
"    const uint state_dim\n"
") {\n"
"    uint tid = get_global_id(0);\n"
"    uint stride = 1u << qubit_index;\n"
"    uint num_pairs = state_dim / 2;\n"
"    if (tid >= num_pairs) return;\n"
"    uint mask = stride - 1;\n"
"    uint base = (tid >> qubit_index) << (qubit_index + 1);\n"
"    uint offset = tid & mask;\n"
"    uint idx0 = base + offset;\n"
"    uint idx1 = idx0 + stride;\n"
"    complex_t amp0 = amplitudes[idx0];\n"
"    complex_t amp1 = amplitudes[idx1];\n"
"    amplitudes[idx0] = (complex_t)(amp1.y, -amp1.x);\n"
"    amplitudes[idx1] = (complex_t)(-amp0.y, amp0.x);\n"
"}\n"
"\n"
"// Pauli Z gate\n"
"__kernel void pauli_z(\n"
"    __global complex_t* amplitudes,\n"
"    const uint qubit_index,\n"
"    const uint state_dim\n"
") {\n"
"    uint tid = get_global_id(0);\n"
"    if (tid >= state_dim) return;\n"
"    uint mask = 1u << qubit_index;\n"
"    if (tid & mask) {\n"
"        amplitudes[tid] = cneg(amplitudes[tid]);\n"
"    }\n"
"}\n"
"\n"
"// Phase gate\n"
"__kernel void phase_gate(\n"
"    __global complex_t* amplitudes,\n"
"    const uint qubit_index,\n"
"    const float phase,\n"
"    const uint state_dim\n"
") {\n"
"    uint tid = get_global_id(0);\n"
"    if (tid >= state_dim) return;\n"
"    uint mask = 1u << qubit_index;\n"
"    if (tid & mask) {\n"
"        complex_t phase_factor = cpolar(1.0f, phase);\n"
"        amplitudes[tid] = cmul(amplitudes[tid], phase_factor);\n"
"    }\n"
"}\n"
"\n"
"// CNOT gate\n"
"__kernel void cnot_gate(\n"
"    __global complex_t* amplitudes,\n"
"    const uint control_qubit,\n"
"    const uint target_qubit,\n"
"    const uint state_dim\n"
") {\n"
"    uint tid = get_global_id(0);\n"
"    if (tid >= state_dim) return;\n"
"    uint control_mask = 1u << control_qubit;\n"
"    uint target_mask = 1u << target_qubit;\n"
"    if ((tid & control_mask) && !(tid & target_mask)) {\n"
"        uint partner = tid | target_mask;\n"
"        complex_t temp = amplitudes[tid];\n"
"        amplitudes[tid] = amplitudes[partner];\n"
"        amplitudes[partner] = temp;\n"
"    }\n"
"}\n"
"\n"
"// Batch Grover search\n"
"__kernel void grover_batch_search(\n"
"    __global complex_t* batch_states,\n"
"    __global const uint* targets,\n"
"    __global uint* results,\n"
"    const uint num_searches,\n"
"    const uint num_qubits,\n"
"    const uint num_iterations\n"
") {\n"
"    uint search_id = get_group_id(0);\n"
"    uint lid = get_local_id(0);\n"
"    uint local_size = get_local_size(0);\n"
"    if (search_id >= num_searches) return;\n"
"    uint state_dim = 1u << num_qubits;\n"
"    uint target = targets[search_id];\n"
"    __global complex_t* amplitudes = batch_states + (search_id * state_dim);\n"
"    __local complex_t local_sum[256];\n"
"    for (uint iter = 0; iter < num_iterations; iter++) {\n"
"        if (lid == 0) {\n"
"            amplitudes[target] = cneg(amplitudes[target]);\n"
"        }\n"
"        barrier(CLK_GLOBAL_MEM_FENCE);\n"
"        complex_t sum = (complex_t)(0.0f, 0.0f);\n"
"        for (uint i = lid; i < state_dim; i += local_size) {\n"
"            sum = cadd(sum, amplitudes[i]);\n"
"        }\n"
"        local_sum[lid] = sum;\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        for (uint s = local_size / 2; s > 0; s >>= 1) {\n"
"            if (lid < s) {\n"
"                local_sum[lid] = cadd(local_sum[lid], local_sum[lid + s]);\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"        complex_t avg = cscale(local_sum[0], 1.0f / (float)state_dim);\n"
"        complex_t two_avg = cscale(avg, 2.0f);\n"
"        for (uint i = lid; i < state_dim; i += local_size) {\n"
"            amplitudes[i] = csub(two_avg, amplitudes[i]);\n"
"        }\n"
"        barrier(CLK_GLOBAL_MEM_FENCE);\n"
"    }\n"
"    if (lid == 0) {\n"
"        float max_prob = 0.0f;\n"
"        uint max_state = 0;\n"
"        for (uint i = 0; i < state_dim; i++) {\n"
"            float prob = cabs2(amplitudes[i]);\n"
"            if (prob > max_prob) {\n"
"                max_prob = prob;\n"
"                max_state = i;\n"
"            }\n"
"        }\n"
"        results[search_id] = max_state;\n"
"    }\n"
"}\n"
